#ОСНОВЫ JS
---------

ОПЕРАТОРЫ
---------
Побитовые операторы
-------------------
    AND(и) ( & )
    OR(или) ( | )
    XOR(побитовое исключающее или) ( ^ )
    NOT(не) ( ~ )
    LEFT SHIFT(левый сдвиг) ( << )
    RIGHT SHIFT(правый сдвиг) ( >> )
    ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
    
Функции для работы с побитовыми операторами
var access = parseInt('110000', 2); //Получение числа из строки
var access = access.toString(2) //Обратно двоичную строку из числа

#ОСНОВЫ РАБОТЫ С СОБЫТИЯМИ
-------------------------
INTRO BROWSER EVENT
-------------------
Есть три способа назначения обработчиков событий:
Атрибут HTML: onclick="...".
Свойство: elem.onclick = function.
Специальные методы:
Современные: elem.addEventListener( событие, handler[, phase]), удаление через removeEventListener.
Для старых IE8-: elem.attachEvent( on+событие, handler ), удаление через detachEvent.
ПОРЯДОК ОБРАБОТКИ СОБЫТИЙ
-------------------------

    1) JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы Web Workers, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.
    2) Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.
    3) Синхронными являются вложенные события, инициированные из кода.
    4) Чтобы сделать событие гарантированно асинхронным, используется вызов через setTimeout(func, 0).

ОБЪЕКТ СОБЫТИЯ
--------------
Он передается первым аргументом event в обработчик для всех браузеров, кроме IE8-, в которых используется глобальная переменная window.event.
ВСПЛЫТИЕ И ПЕРЕХВАТ
-------------------
http://learn.javascript.ru/event-bubbling
Алгоритм:

    При наступлении события – элемент, на котором оно произошло, помечается как «целевой» (event.target).
    Далее событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true).
    Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on* и addEventListener(...., false).

Каждый обработчик имеет доступ к свойствам события:

    event.target – самый глубокий элемент, на котором произошло событие.
    event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие).
    event.eventPhase – на какой фазе он сработал (погружение =1, всплытие = 3).

Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко.

Этому есть две причины:

    Историческая – так как IE лишь с версии 9 в полной мере поддерживает современный стандарт.

    Разумная – когда происходит событие, то разумно дать возможность первому сработать обработчику на самом элементе, поскольку он наиболее конкретен. Код, который поставил обработчик именно на этот элемент, знает максимум деталей о том, что это за элемент, чем он занимается.

    Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document, обработчик на котором реализовывает самую общую функциональность уровня документа.
