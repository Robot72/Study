#ОСНОВЫ JS
---------

ОПЕРАТОРЫ
---------
Побитовые операторы
-------------------
    AND(и) ( & )
    OR(или) ( | )
    XOR(побитовое исключающее или) ( ^ )
    NOT(не) ( ~ )
    LEFT SHIFT(левый сдвиг) ( << )
    RIGHT SHIFT(правый сдвиг) ( >> )
    ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
    
Функции для работы с побитовыми операторами
var access = parseInt('110000', 2); //Получение числа из строки
var access = access.toString(2) //Обратно двоичную строку из числа

#ОСНОВЫ РАБОТЫ С СОБЫТИЯМИ
-------------------------
INTRO BROWSER EVENT
-------------------
Есть три способа назначения обработчиков событий:
Атрибут HTML: onclick="...".
Свойство: elem.onclick = function.
Специальные методы:
Современные: elem.addEventListener( событие, handler[, phase]), удаление через removeEventListener.
Для старых IE8-: elem.attachEvent( on+событие, handler ), удаление через detachEvent.
ПОРЯДОК ОБРАБОТКИ СОБЫТИЙ
-------------------------

    1) JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы Web Workers, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.
    2) Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.
    3) Синхронными являются вложенные события, инициированные из кода.
    4) Чтобы сделать событие гарантированно асинхронным, используется вызов через setTimeout(func, 0).

ОБЪЕКТ СОБЫТИЯ
--------------
Он передается первым аргументом event в обработчик для всех браузеров, кроме IE8-, в которых используется глобальная переменная window.event.
ВСПЛЫТИЕ И ПЕРЕХВАТ
-------------------
http://learn.javascript.ru/event-bubbling
Алгоритм:

    - При наступлении события – элемент, на котором оно произошло, помечается как «целевой» (event.target).
    - Далее событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true).
    - Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on* и addEventListener(...., false).

Каждый обработчик имеет доступ к свойствам события:

    - event.target – самый глубокий элемент, на котором произошло событие.
    - event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие).
    - event.eventPhase – на какой фазе он сработал (погружение =1, всплытие = 3).

Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко.

Этому есть две причины:

    1) Историческая – так как IE лишь с версии 9 в полной мере поддерживает современный стандарт.

    2) Разумная – когда происходит событие, то разумно дать возможность первому сработать обработчику на самом элементе, поскольку он наиболее конкретен. Код, который поставил обработчик именно на этот элемент, знает максимум деталей о том, что это за элемент, чем он занимается.

    Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document, обработчик на котором реализовывает самую общую функциональность уровня документа.
ДЕЛЕГИРОВАНИЕ СОБЫТИЙ
---------------------
Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM. Он отлично подходит, если есть много элементов, обработка которых очень схожа.

Алгоритм:

    1) Вешаем обработчик на контейнер.
    2) В обработчике: получаем event.target.
    3) В обработчике: если event.target или один из его родителей в контейнере (this) – интересующий нас элемент – обработать его.

Зачем использовать:

    - Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.
    - Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
    - Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.

Конечно, у делегирования событий есть свои ограничения.

    - Во-первых, событие должно всплывать. Нельзя, чтобы какой-то промежуточный обработчик вызвал event.stopPropagation() до того, как событие доплывёт до нужного элемента.
    - Во-вторых, делегирование создает дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, её даже не стоит принимать во внимание.
    
ПРИЕМ ПРОЕКТИРОВАНИЯ "ПОВЕДЕНИЕ"
--------------------------------
Прием состоит из двух частей:

    1)Элементу ставится атрибут, описывающий его поведение.
    2)При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.

Шаблон «поведение» удобен тем, что сколь угодно сложное JavaScript-поведение можно «навесить» на элемент одним лишь атрибутом. А можно – несколькими атрибутами на связанных элементах.
ДЕЙСТВИЯ БРАУЗЕРА ПО-УМОЛЧАНИЮ
------------------------------

    1) Браузер имеет встроенные действия при ряде событий – переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.
    2) Есть два способа отменить действие по умолчанию: первый – использовать event.preventDefault() (IE8-: event.returnValue=false), второй – return false из обработчика. Второй способ работает только если обработчик назначен через onсобытие.
ГЕНЕРАЦИЯ СОБЫТИЙ НА ЭЛЕМЕНТАХ
------------------------------
В 98% случаев, когда разработчик начинающего или среднего уровня хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода, и взаимодействие нужно на уровне выше.
Как правило события имеет смысл генерировать:

    Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
    Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.
    Либо при создании своих «элементов интерфейса». Например, никто не мешает при помощи JavaScript создать из <div class="calendar"> красивый календарь и генерировать на нём событие change при выборе даты. Эту тему мы разовьём позже.

#СОБЫТИЯ В ДЕТАЛЯХ

#РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
Паттерны и флаги
----------------

- Регулярное выражение состоит из шаблона и необязательных флагов g(много совпадений), i(нет регистровой зависимости) и m(включает многострочный режим).
- Поиск по регулярному выражению без флагов и спец. символов, которые мы изучим далее – это то же самое, что и обычный поиск подстроки в строке. Но флаги и спец. символы, как мы увидим далее, могут сделать его гораздо мощнее.
- Метод строки str.search(regexp) возвращает индекс, на котором найдено совпадение.
